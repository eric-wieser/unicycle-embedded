/**
 * This file implements static dispatch of message handlers.
 *
 * Ideally, it would be mostly generated by nanopb, but as that is a C package,
 * it is not.
 *
 * To add a new message type `Msg`, you need to add to `msg_types`, and declare a
 * `field_info` template specialization containing the pointer-to-member and
 * tag value.
 *
 * Doing that will expose `onMessage<Msg>(...)` and add to the list of handlers
 * in `try_handlers()`.
 *
 * Failing to do so
 */
#pragma once

#include "messages.pb.h"

namespace {

/**
 * @brief  Linked list of types, not values.
 *
 *   list::head refers to the first type, list::tail to the remaining types
 *
 */
template<typename... T> struct type_list {};
template<> struct type_list<> {};
template<typename H, typename... T> struct type_list<H, T...> {
    typedef H head;
    typedef type_list<T...> tail;
};

/**
 * The list of all the message types that have handlers
 */
typedef type_list<
    Go,
    Stop,
    Controller,
    GetLogs,
    CalibrateGyro
> msg_types;

/**
 * @brief Metadata about each of the field types
 *
 * Ideally, this would be generated by nanopb, but that does not know about
 * C++.
 */
template <typename T> struct field_info {};
#define DECLARE_FIELD_INFO(ftype, fname) \
    template<> struct field_info<ftype> { \
        static constexpr auto value = &decltype(PCMessage::msg)::fname; \
        static constexpr int tag = PCMessage_ ## fname ## _tag; \
    };

    // macros are nasty, but there
    DECLARE_FIELD_INFO(Go, go);
    DECLARE_FIELD_INFO(Stop, stop);
    DECLARE_FIELD_INFO(Controller, controller);
    DECLARE_FIELD_INFO(GetLogs, get_logs);
    DECLARE_FIELD_INFO(CalibrateGyro, calibrate);
#undef DECLARE_FIELD_INFO

/**
 * @brief   Try to invoke the handler for a T type message
 *
 * @return  true if the handler is the right type, whether or not it is attached
 */
template<typename T>
inline bool try_handler(const PCMessage &message) {
    if (message.which_msg == field_info<T>::tag) {
        auto handler = messageHandlers<T>::handler;
        if (handler) {
            handler(message.msg.*(field_info<T>::value));
        }
        return true;
    }
    else {
        return false;
    }
}

// helper functions for the below - template specialization does not work on
// plain functions, so we use structs.
template<typename T>
struct try_handlers_helper {
    static inline bool f(const PCMessage &message) {
        return try_handler<typename T::head>(message) ||
               try_handlers_helper<typename T::tail>::f(message);
    }
};
template<>
struct try_handlers_helper<type_list<>> {
    static inline bool f(const PCMessage &message) {
        return false;
    }
};
/**
 * @brief  Try each of the handlers in turn, calling `try_handler`
 *
 * @return true if the type was recognized
 */
inline bool try_handlers(const PCMessage &message) {
    return try_handlers_helper<msg_types>::f(message);
}

}